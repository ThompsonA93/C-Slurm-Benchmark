\chapter{Methods and Resources}

The algorithms were executed on a AMD EPYC 7702P 64-Core Processor 
via the programming language C and the library OpenMP.
The program implementations are available on 
\href{https://github.com/ThompsonA93/C-Slurm-Benchmark}{Github.com}.

The methodical approach was to run each program execution 
with different input parameters, ranging from different element 
dimension to varying amounts of threads utilized.
Lastly, the result is compared to the sequential version of the 
same algorithm to check the validity of the final result.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}\hline
        Algorithm & Elements & Threads \\\hline
        Quicksort & 50000 100000 150000 200000 250000 &  1 2 4 8 \\\hline
        Sieve & 10000000 20000000 30000000 40000000 50000000 & 1 2 4 8 \\\hline
        Dijkstra & 10000 20000 30000 40000 & 1 2 4 8 \\\hline
        Gauss & 500 1000 1500 2000 2500 & 1 2 4 8 \\\hline
        
    \end{tabular}
    \caption{The parametrization of each algorithm. Each process execution would run the set number of threads with each of the stated amount of elements.}
    \label{tab:my_label}
\end{table}

Notably, the speedup was calculated as $S_p = T_1 / T_p$, where $T$ is the execution time and $p$ is the amount of processors,
while the efficiency is calculated as $E_p = S_p / p$, where $S_p$ is the speedup and $p$ is the amount of processors utilized.